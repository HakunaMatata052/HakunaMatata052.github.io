{"meta":{"title":"程序园-ICU","subtitle":"程序猿的重点-ICU!","description":"一只前端小神的Blog","author":"Hakunamatata","url":"https://hakunamatata052.github.io","root":"/"},"pages":[{"title":"分类","date":"2018-12-19T07:12:16.000Z","updated":"2022-01-01T15:36:46.730Z","comments":true,"path":"categories/index.html","permalink":"https://hakunamatata052.github.io/categories/index.html","excerpt":"","text":""},{"title":"dome1","date":"2018-12-19T07:38:28.000Z","updated":"2020-08-21T04:37:16.000Z","comments":true,"path":"dome1/index.html","permalink":"https://hakunamatata052.github.io/dome1/index.html","excerpt":"","text":"dome1 .box { width: 20em; height: 10em; border: 1px solid #ddd; overflow: hidden; } .list { height: 100%; background: #ddd; text-align: center; position: relative; } .list input { position: absolute; top:0; height: 100%; width: 1px; border:0; padding: 0; margin: 0; clip: rect(0 0 0 0); } 1 2 3 4 1 2 3 4"},{"title":"留言","date":"2018-12-26T02:00:45.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"comments/index.html","permalink":"https://hakunamatata052.github.io/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-19T07:29:11.000Z","updated":"2022-01-01T15:27:41.700Z","comments":true,"path":"tags/index.html","permalink":"https://hakunamatata052.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"threeJs模型压缩、加载","slug":"threejs-compress","date":"2021-11-01T04:00:00.000Z","updated":"2021-11-01T07:46:38.495Z","comments":true,"path":"2021/11/01/threejs-compress/","link":"","permalink":"https://hakunamatata052.github.io/2021/11/01/threejs-compress/","excerpt":"压缩模型安装压缩器全局安装gltf-pipelinegit地址：https://gitee.com/apis-cloud/gltf-pipeline.git1sudo npm install -g gltf-pipeline 转换格式如果是glb或fbx格式，首选需要转换格式glft，这个插件是自带格式转换的在模型所在文件夹执行命令1gltf-pipeline -i model.glb -j","text":"压缩模型安装压缩器全局安装gltf-pipelinegit地址：https://gitee.com/apis-cloud/gltf-pipeline.git1sudo npm install -g gltf-pipeline 转换格式如果是glb或fbx格式，首选需要转换格式glft，这个插件是自带格式转换的在模型所在文件夹执行命令1gltf-pipeline -i model.glb -j 执行压缩再执行压缩操作（model.gltf是转换格式后的文件名，modelDraco.gltf是压缩后的文件名）1gltf-pipeline -i model.gltf -o modelDraco.gltf -d -s压缩后得到两个文件 modelDraco.gltf modelDraco.bin 将两个文件放在DRACOLoader指定的文件夹即可 导入模型最后使用DRACOLoader加载器加载压缩模型即可点击下载WASM/JS解码库文件123456789var loader = new GLTFLoader() //创建模型加载器对象var dracoloader = new DRACOLoader() //draco加载器(压缩模型解码器) dracoloader.setDecoderPath( &#x27;stl/&#x27; ) //指定包含WASM / JS解码库的文件夹的路径。loader.setDRACOLoader( dracoloader ) loader.load(&quot;stl/modelDraco.gltf&quot;, gltf =&gt; &#123; gltf.scene.scale.set(10, 10, 10) gltf.scene.position.set(0, -0.2, 0) this.scene.add(gltf.scene)&#125;)","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"three.js","slug":"JS/three-js","permalink":"https://hakunamatata052.github.io/categories/JS/three-js/"}],"tags":[{"name":"three.js","slug":"three-js","permalink":"https://hakunamatata052.github.io/tags/three-js/"},{"name":"threejs","slug":"threejs","permalink":"https://hakunamatata052.github.io/tags/threejs/"},{"name":"three","slug":"three","permalink":"https://hakunamatata052.github.io/tags/three/"}]},{"title":"封装微信小程序请求","slug":"requset","date":"2021-05-07T02:05:00.000Z","updated":"2021-05-07T02:26:41.648Z","comments":true,"path":"2021/05/07/requset/","link":"","permalink":"https://hakunamatata052.github.io/2021/05/07/requset/","excerpt":"登录流程首先看下小程序官方的登录流程图大致的登录流程是这样的： 前端：小程序请求是先使用wx.checkSession验证小程序服务器登录态是否失效，如果失效，则使用wx.login进行登录，然后获取到code发送给业务服务器。 后端：业务服务器拿到code后请求小程序服务器获取用户的openid等信息。 后端：业务服务器使用openid去匹配服务器中用户的数据，如果openid存在，说明用户已注册，如果不存在，则直接注册一个用户，并将openid保存在数据库以便下次验证。 后端：如果用户已注册，后端直接执行登录操作，即返回用户的业务登录态（token），也可以加上需要的用户信息等。 前端：拿到业务端的登录态后，再次携带登录态访问业务端接口。 后端：验证用户登录态是否有效，有效则返回业务接口数据。 后端：无效则返回登录态失效信息。 前端：如果请求返回的是登录态失效，则再次使用wx.login拿到code请求业务端登录接口，获取业务的登录态。 前端：如果验证小程序登录态没有失效，则前端直接请求业务端接口（请求中携带业务端登录态，即业务的token）。 后端：验证用户登录态是否有效，有效则返回业务接口数据。 后端：无效则返回登录态失效信息。 前端：如果请求返回的是登录态失效，则再次使用wx.login拿到code请求业务端登录接口，获取业务的登录态。大致的前后端流程就是这样。","text":"登录流程首先看下小程序官方的登录流程图大致的登录流程是这样的： 前端：小程序请求是先使用wx.checkSession验证小程序服务器登录态是否失效，如果失效，则使用wx.login进行登录，然后获取到code发送给业务服务器。 后端：业务服务器拿到code后请求小程序服务器获取用户的openid等信息。 后端：业务服务器使用openid去匹配服务器中用户的数据，如果openid存在，说明用户已注册，如果不存在，则直接注册一个用户，并将openid保存在数据库以便下次验证。 后端：如果用户已注册，后端直接执行登录操作，即返回用户的业务登录态（token），也可以加上需要的用户信息等。 前端：拿到业务端的登录态后，再次携带登录态访问业务端接口。 后端：验证用户登录态是否有效，有效则返回业务接口数据。 后端：无效则返回登录态失效信息。 前端：如果请求返回的是登录态失效，则再次使用wx.login拿到code请求业务端登录接口，获取业务的登录态。 前端：如果验证小程序登录态没有失效，则前端直接请求业务端接口（请求中携带业务端登录态，即业务的token）。 后端：验证用户登录态是否有效，有效则返回业务接口数据。 后端：无效则返回登录态失效信息。 前端：如果请求返回的是登录态失效，则再次使用wx.login拿到code请求业务端登录接口，获取业务的登录态。大致的前后端流程就是这样。 然后需要将上面的流程中的前端请求封装一下。调用的时候直接使用：1http(route, data, config).then(res=&#123;&#125;).catch=(err=&gt;&#123;&#125;) config暂时没有写配置，可以自定义一下，如请求方式（get，post…），还有是否弹出错误提示和正确提示，是否显示加载等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function request(route, data, config) &#123; return new Promise(async (resolve, reject) =&gt; &#123; wx.request(&#123; url: `http://127.0.0.1:81/index.php?s=/api/$&#123;route&#125;`, data: &#123; ...data, token: wx.getStorageSync(&#x27;token&#x27;), &#125;, method: config &amp;&amp; config.method || &#x27;post&#x27;, header: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;, success(res) &#123; resolve(res) &#125;, fail() &#123; reject() &#125; &#125;) &#125;)&#125;// 重新获取jscodefunction login() &#123; return new Promise((resolve, reject) =&gt; &#123; wx.login(&#123; success: res =&gt; &#123; request(&#x27;user/login&#x27;, &#123; code: res.code &#125;).then(res =&gt; &#123; resolve(res) wx.setStorageSync(&#x27;token&#x27;, res.data.data.token) &#125;).catch(err =&gt; &#123; reject() &#125;) &#125; &#125;) &#125;)&#125;// 小程序登录态失效function checkSession() &#123; return new Promise((resolve, reject) =&gt; &#123; wx.checkSession(&#123; success: () =&gt; &#123; const token = wx.getStorageSync(&#x27;token&#x27;) if (token) &#123; resolve(false) &#125; else &#123; resolve(true) &#125; &#125;, fail: () =&gt; &#123; resolve(true) &#125; &#125;) &#125;)&#125;export default async function http(route, data) &#123; if (await checkSession()) &#123; await login() &#125; const res = await request(route, data) if (res.data.code == 2) &#123; await login() return request(route, data) &#125; return res&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"miniapp","slug":"JS/miniapp","permalink":"https://hakunamatata052.github.io/categories/JS/miniapp/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://hakunamatata052.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"请求封装","slug":"请求封装","permalink":"https://hakunamatata052.github.io/tags/%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/"}]},{"title":"小程序和H5中input在光标位置中插入","slug":"cursor-position-insert","date":"2021-04-16T02:25:36.000Z","updated":"2021-04-16T06:11:38.078Z","comments":true,"path":"2021/04/16/cursor-position-insert/","link":"","permalink":"https://hakunamatata052.github.io/2021/04/16/cursor-position-insert/","excerpt":"最近遇到一个需要是聊天添加表情功能，本来很简单，点就表情追加到input内容里即可。但是表情只能追加到字符串最后面，这就很恼火。有没有办法在光标制定位置插入呢？当然有，只不过小程序做法和H5略有区别，这里两种都介绍一下。","text":"最近遇到一个需要是聊天添加表情功能，本来很简单，点就表情追加到input内容里即可。但是表情只能追加到字符串最后面，这就很恼火。有没有办法在光标制定位置插入呢？当然有，只不过小程序做法和H5略有区别，这里两种都介绍一下。 首先是H5这里我直接抛出代码，原理也很简单，主要利用的是input和textarea中的setSelectionRange属性获取光标位置。这里不做过多解释，主要看下小程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function setCaret(textObj) &#123; if (textObj.createTextRange) &#123; textObj.caretPos = document.selection.createRange().duplicate(); &#125; &#125; function insertAtCaret(textObj, textFeildValue) &#123; if (document.all) &#123; if (textObj.createTextRange &amp;&amp; textObj.caretPos) &#123; var caretPos = textObj.caretPos; caretPos.text = caretPos.text.charAt(caretPos.text.length - 1) == &#x27; &#x27; ? textFeildValue + &#x27; &#x27; : textFeildValue; &#125; else &#123; textObj.value = textFeildValue; &#125; &#125; else &#123; console.log(1) if (textObj.setSelectionRange) &#123; var rangeStart = textObj.selectionStart; var rangeEnd = textObj.selectionEnd; var tempStr1 = textObj.value.substring(0, rangeStart); var tempStr2 = textObj.value.substring(rangeEnd); textObj.value = tempStr1 + textFeildValue + tempStr2; &#125; else &#123; alert(&quot;This version of Mozilla based browser does not support setSelectionRange&quot;); &#125; &#125; &#125; &lt;/script&gt; &lt;form id=&quot;form1&quot; action=&quot;&quot; onsubmit=&quot;&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot;&gt; &lt;p&gt; &lt;textarea id=&quot;textarea&quot; name=&quot;tarea&quot; rows=&quot;&quot; cols=&quot;&quot; style=&quot;width:300px;height:120px;&quot; onselect=&quot;setCaret(this);&quot; onclick=&quot;setCaret(this);&quot; onkeyup=&quot;setCaret(this);&quot;&gt;例子例子例子例子例子&lt;/textarea&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;textfield&quot; style=&quot;width:220px;&quot; value=&quot;插入FireFox&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;button&quot; value=&quot;插入&quot; onclick=&quot;insertAtCaret(this.form.tarea,this.form.textfield.value);&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;div id=&quot;box&quot; contenteditable=&quot;true&quot; style=&quot;border:1px solid #ccc; width:300px; height:200px;&quot;&gt;sljfldjfldf&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 小程序小程序需要在textarea或input中绑定失焦事件bindblur=&quot;onBlur&quot;1&lt;textarea id=&quot;textarea&quot; auto-focus=&quot;true&quot; placeholder=&quot;请输入文章内容&quot; value=&quot;&#123;&#123;content&#125;&#125;&quot; bindinput=&quot;onInput&quot; bindblur=&quot;onBlur&quot;/&gt;然后在失焦事件获取失焦时光标的位置，即光标在文本域中的下标12345onBlur(e) &#123; this.setData(&#123; cursor: e.detail.cursor &#125;)&#125;,然后在插入表情的实践中将表情插入文本域字符串中（也就是表情的点击事件中）12345678inputGif(e) &#123; const index = e.currentTarget.dataset.index setTimeout(() =&gt; &#123; this.setData(&#123; content: this.data.content.slice(0, this.data.cursor) + this.data.gif[index].code + this.data.content.slice(this.data.cursor) &#125;) &#125;, 100)&#125;,这里我使用了setTimeout延时了100ms执行，原因是如果执行，失焦实践是在点击事件之后触发的，就会出现插入的位置是上一次失焦时的位置，所以需要插入时延迟100ms先让文本域失焦并设置好光标位置，再执行插入。至此小程序的光标制定位置插入内容就完成了，有木有很简单。","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"nimiapp","slug":"JS/nimiapp","permalink":"https://hakunamatata052.github.io/categories/JS/nimiapp/"}],"tags":[{"name":"setSelectionRange","slug":"setSelectionRange","permalink":"https://hakunamatata052.github.io/tags/setSelectionRange/"},{"name":"光标位置插入","slug":"光标位置插入","permalink":"https://hakunamatata052.github.io/tags/%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5/"}]},{"title":"使用uniapp打包H5时使用微信SDK","slug":"uniapp-wxSDK","date":"2021-03-13T02:25:36.000Z","updated":"2021-04-16T02:02:53.932Z","comments":true,"path":"2021/03/13/uniapp-wxSDK/","link":"","permalink":"https://hakunamatata052.github.io/2021/03/13/uniapp-wxSDK/","excerpt":"起因原本的一个需求是开发微信小程序，但是因为产品变更需求，需要重新改为H5，为了重构页面和前端逻辑不做太大改动，所以决定先把小程序改为uniapp，在用uniapp打包为H5因为uniapp里的方法和小程序类似，所以代码复用率高。有了思路之后就开始着手进行。","text":"起因原本的一个需求是开发微信小程序，但是因为产品变更需求，需要重新改为H5，为了重构页面和前端逻辑不做太大改动，所以决定先把小程序改为uniapp，在用uniapp打包为H5因为uniapp里的方法和小程序类似，所以代码复用率高。有了思路之后就开始着手进行。 第一步：将微信小程序转为uniapp这里使用的是官方出的一款插件miniprogram-to-uniapp 安装使用命令行进行全局安装 windows:1npm install miniprogram-to-uniapp -gmac &amp; Linux:1sudo npm install miniprogram-to-uniapp -g 验证使用命令wtu -V验证是否安装成功，返回版本号说明安装成功 转换使用命令wtu -i 小程序根目录路径进行转换小程序根目录路径可以是绝对路径，也可以是命令行打开的相对路径转换成功后在小程序目录同级目录下会生成一个文件名_uni的文件夹 这里存放的就是转换后的uniapp，你可以是用Hbuilder打开，或者使用官方脚手架然后用vscode打开，笔者使用的后者。 第二步引入微信SDK由于我们小程序内获取的登录态是小程序的，如果改成微信内登录的H5，需要将登录态转换为微信H5的登录态。这里就需要用到微信的SDK。由于笔者使用的uniapp脚手架，所以需要修改public目录下的index.html文件，即H5的模版文件。（Hbuilder打开的话需要在配置文件中配置模版文件） 引入微信SDK1&lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot;&gt;&lt;/script&gt; 然后在你需要调用的组建里配置微信SDK12345678wx.config(&#123; debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: &#x27;&#x27;, // 必填，企业号的唯一标识，此处填写企业号corpid timestamp: , // 必填，生成签名的时间戳 nonceStr: &#x27;&#x27;, // 必填，生成签名的随机串 signature: &#x27;&#x27;,// 必填，签名，见附录1 jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2&#125;);这个时候问题就来了！执行会发现wx对象中没有config方法,但是wx对象是存在的？ 原因原来是因为uniapp中已经向window中声明了一个wx变量，这个wx变量是小程序的wx对象而不是微信SDK的。因为uniapp在打包时将app.js打包在了&lt;/body&gt;之前，所以我们引入的微信SDK的变量被uniapp的覆盖了。 解决找到原因就好办了，直接将SDK在&lt;/body&gt;之后&lt;/html&gt;之前引入。 再跑一下，完美解决！ 总结这里找问题原因花了很长时间，因为引入js方式，登录态检测这些我都简化叙述了，还用到了各种抓包，本地代理线上文件。但是思路就是遇到问题可以想想多种解决方案，多打断点，多console。","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"uniapp","slug":"JS/uniapp","permalink":"https://hakunamatata052.github.io/categories/JS/uniapp/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://hakunamatata052.github.io/tags/uniapp/"},{"name":"微信SDK","slug":"微信SDK","permalink":"https://hakunamatata052.github.io/tags/%E5%BE%AE%E4%BF%A1SDK/"}]},{"title":"html转jsx","slug":"html2jsx","date":"2020-08-31T02:18:00.000Z","updated":"2020-08-31T02:36:36.000Z","comments":true,"path":"2020/08/31/html2jsx/","link":"","permalink":"https://hakunamatata052.github.io/2020/08/31/html2jsx/","excerpt":"初衷之前做的一个阿里需求，是将原有的HTML的静态页面重构成前后分离的项目，要求是用dva-cli脚手架来开发那么就牵扯到一个问题就是这么多的HTML页面肯定不能手动转成jsx语法啊。毕竟差别还是有很多的，尤其是写div的类名我们知道，在普通HTML中是这样写div和类名的","text":"初衷之前做的一个阿里需求，是将原有的HTML的静态页面重构成前后分离的项目，要求是用dva-cli脚手架来开发那么就牵扯到一个问题就是这么多的HTML页面肯定不能手动转成jsx语法啊。毕竟差别还是有很多的，尤其是写div的类名我们知道，在普通HTML中是这样写div和类名的1&lt;div class=&quot;demo div1&quot;&gt;&lt;/div&gt;但是在jsx语法中尤其是同一div上应用了多个类名，jsx写起来会很让热挠头1&lt;div className=&#123;[styles.demo,styles.div1].join(&#x27; &#x27;)&#125;&gt;&lt;/div&gt;于是乎就做了一个小工具，可以将html转换为jsx语法，这里需要注意一下styles是我引入的less后赋值的变量名1import styles from &#x27;../assets/css/index.css&#x27; 效果左边输入html点击转换会自动生成在右边的文本域中 原理这个小Demo的原理非常简单，就是通过正则匹配到所有class=“”里的内容，然后通过replace方法替换值得注意的是replace方法的第二个参数可以传一个固定的字符串，也可以传一个函数，函数的返回值作为替换的内容这里我们不能把类名替换成固定的值，而是需要将类名做处理，所有在replace第二个参数中传入一个函数，函数的参数，就是匹配到的内容获得内容就很好办了，先把类名用空格拆分成数组，然后写个jsx中的格式即可 代码12345678910111213141516function submit()&#123; var con = document.getElementById(&#x27;text&#x27;).value con = con.replace(/class=&quot;.*?&quot;/ig, value =&gt;&#123; value = value.replace(&#x27;class=&quot;&#x27;,&#x27;&#x27;).replace(&#x27;&quot;&#x27;,&#x27;&#x27;) value = value.split(&#x27; &#x27;) console.log(value) if(value.length&gt;1)&#123; value = value.map(item=&gt;`styles.$&#123;item&#125;`) value = `[$&#123;value.join(&#x27;,&#x27;)&#125;].join(&#x27; &#x27;)` &#125;else&#123; value = `styles.$&#123;value&#125;` &#125; return `className=&#123;$&#123;value&#125;&#125;` &#125;); document.getElementById(&#x27;text2&#x27;).value = con&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"react","slug":"JS/react","permalink":"https://hakunamatata052.github.io/categories/JS/react/"}],"tags":[{"name":"react jsx","slug":"react-jsx","permalink":"https://hakunamatata052.github.io/tags/react-jsx/"}]},{"title":"Three.js设置DIV跟随场景的两种方法","slug":"three-sprite-css2d","date":"2020-08-26T07:39:00.000Z","updated":"2020-08-26T08:57:16.000Z","comments":true,"path":"2020/08/26/three-sprite-css2d/","link":"","permalink":"https://hakunamatata052.github.io/2020/08/26/three-sprite-css2d/","excerpt":"方法一：使用Sprite对象首先实例化一个SpriteMaterial，设置好材质或颜色，可以是透明的1234let spriteMap = new TextureLoader().load(&quot;./static/img/img.png&quot;);let pinMaterial = new SpriteMaterial(&#123; map: spriteMap&#125;);然后创建一个div或者绑定html上现有的div元素,设置好默认的位置属性，可以用css来设置默认样式123456let Div = document.createElement(&#x27;div&#x27;)Div.className = &#x27;text&#x27;Div.id = &quot;text&quot;Div.style.left = 0 + &#x27;px&#x27;Div.style.top = 0 + &#x27;px&#x27;document.body.appendChild(Div)然后声明一个坐标点并初始化，之后用来保存每次改变后的坐标点","text":"方法一：使用Sprite对象首先实例化一个SpriteMaterial，设置好材质或颜色，可以是透明的1234let spriteMap = new TextureLoader().load(&quot;./static/img/img.png&quot;);let pinMaterial = new SpriteMaterial(&#123; map: spriteMap&#125;);然后创建一个div或者绑定html上现有的div元素,设置好默认的位置属性，可以用css来设置默认样式123456let Div = document.createElement(&#x27;div&#x27;)Div.className = &#x27;text&#x27;Div.id = &quot;text&quot;Div.style.left = 0 + &#x27;px&#x27;Div.style.top = 0 + &#x27;px&#x27;document.body.appendChild(Div)然后声明一个坐标点并初始化，之后用来保存每次改变后的坐标点123private circleData: Vector3...this.circleData = new Vector3(-0.2, 2.3, 0)接着创建一个创建一个Sprite对象（这里我使用的是webpack引用依赖的方式，因此不需要THREE.Sprite）,并设置坐标点是初始化的坐标点1234567let pin: Sprite = new Sprite(pinMaterial);pin.position.set( this.circleData.x, this.circleData.y, this.circleData.z);pin.scale.set(0.3, 0.3, 1);然后写一个方法用来更新坐标点并设置div的坐标，其原理是每次render时使用Vector3中的project方法将Sprite对象中的世界坐标点转换为屏幕坐标点，并且改变div的css位置信息project接受一个参数是相机实例最后通过一个固定公式转换成屏幕坐标点123456789101112131415private textShow(): void &#123; let worldVector = new Vector3( this.circleData.x, this.circleData.y, this.circleData.z ); let standardVector = worldVector.project(this.camera); let a = this.$window.clientWidth / 2; let b = this.$window.clientHeight / 2; let x = Math.round(standardVector.x * a + a); let y = Math.round(-standardVector.y * b + b); let Div: HTMLElement = document.getElementById(&#x27;text&#x27;) Div.style.left = x + 30 + &quot;px&quot;; Div.style.top = y + &quot;px&quot;;&#125;最后在render方法中调用textShow方法即可123456private render(): void &#123; window.requestAnimationFrame(() =&gt; this.render()); this.textShow(); this.renderer.render(this.scene, this.camera); // 必须放在这个位置 &#125; 方法二：使用CSS2DObject和CSS2DRenderer渲染器这个方法的原理是将dom元素通过CSS2DObject方法转换为three对象，然后利用CSS2DRenderer渲染器将其渲染在页面上首先引入CSS2DObject和CSS2DRenderer1import &#123; CSS2DObject, CSS2DRenderer &#125; from &quot;three/examples/jsm/renderers/CSS2DRenderer&quot;;接着声明一个CSS2DRenderer1private labelRenderer: CSS2DRenderer新建一个div设置一些类名或者样式，然后将div传入CSS2DObject对象的实例中将实例add进场景，再声明一个CSS2DRenderer，通过setSize方法设置渲染器的大小通过labelRenderer.domElement来设置被转换成three对象之后的dom元素的样式最后将labelRenderer.domElement对象appendChild到你想要的元素中12345678910111213const Div: HTMLElement = document.createElement(&#x27;div&#x27;)Div.id = &#x27;trace&#x27;Div.className = &#x27;text&#x27;Div.textContent = &quot;CSS2D方法&quot;var moonLabel = new CSS2DObject(Div);moonLabel.position.set(0, -3, 0);this.scene.add(moonLabel);this.labelRenderer = new CSS2DRenderer();this.labelRenderer.setSize(window.innerWidth, window.innerHeight);this.labelRenderer.domElement.style.position = &#x27;absolute&#x27;;this.labelRenderer.domElement.style.top = 0 + &#x27;px&#x27;; document.body.appendChild(this.labelRenderer.domElement)最后直接再render方法中执行labelRenderer的render，传入场景和相机1this.labelRenderer.render(this.scene, this.camera);这里有个问题，如果场景有OrbitControls控制器，那么将会失效，因为CSS2DRenderer会先生成有个和渲染大小一样的div（就是setSize方法设置的大小）如果能正常显示出div那么它的z-index是高于WebGLRenderer渲染出的canvas的层级，这样OrbitControls控制器就会失效解决方法也很简单粗暴：给这个生成出来的div给一个pointer-events: none;样式即可 相比之下，我觉得方案二还是更简单一点，但是如果需要设置多个或不确定数量的div，那么可以使用第一个，使用for循环来处理 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344import &#x27;./assets/less/index.less&#x27;import &#123; OrbitControls &#125; from &#x27;three/examples/jsm/controls/OrbitControls&#x27;;import &#123; Scene, PerspectiveCamera, WebGLRenderer, AmbientLight, DirectionalLight, AnimationMixer, AnimationAction, BoxGeometry, MeshBasicMaterial, Mesh, DoubleSide, Clock, Raycaster, Vector2, Vector3, Group, TextureLoader, Sprite, SpriteMaterial, LoopOnce &#125; from &quot;three&quot;;import &#123; GLTFLoader, GLTF &#125; from &quot;three/examples/jsm/loaders/GLTFLoader&quot;;import &#123; CSS2DObject, CSS2DRenderer &#125; from &quot;three/examples/jsm/renderers/CSS2DRenderer&quot;;export class Three &#123; private scene: Scene private camera: PerspectiveCamera private renderer: WebGLRenderer private controls: OrbitControls private mixer: AnimationMixer private clock: Clock private mainGroup: Group private circleGroup: Group private $window: HTMLElement private fov: number private originalCamera: Vector3 private circleData: Vector3 private gltf: GLTF private anindex: number private animation: AnimationAction private isAnimate: boolean private labelRenderer: CSS2DRenderer constructor() &#123; this.fov = 26 this.originalCamera = new Vector3(-2.3363492363063805, 5.3542278380602655, 13.216669448945213) this.$window = document.querySelector(&quot;#app&quot;); this.clock = new Clock() this.circleData = new Vector3(-0.2, 2.3, 0) this.anindex = 0 this.isAnimate = false this.initScene(); this.initThree(); this.initCamera(); this.initControls() this.initLight(); this.initPulseCircle() this.initTrace() this.render() window.addEventListener(&#x27;resize&#x27;, () =&gt; this.onWindowResize()); this.renderer.domElement.addEventListener(&quot;click&quot;, event =&gt; this.modelTrigger(event)); this.renderer.domElement.addEventListener(&quot;touchstart&quot;, event =&gt; this.modelTrigger(event)); let loader = new GLTFLoader(); //创建模型加载器对象 // let dracoloader = new DRACOLoader();//draco加载器 const textureLoader = new TextureLoader(); const skyboxGeometry = new BoxGeometry(200, 200, 200); const skyboxMaterials = [ new MeshBasicMaterial(&#123; map: textureLoader.load(&#x27;./static/textures/rt.png&#x27;), side: DoubleSide &#125;), new MeshBasicMaterial(&#123; map: textureLoader.load(&#x27;./static/textures/lf.png&#x27;), side: DoubleSide &#125;), new MeshBasicMaterial(&#123; map: textureLoader.load(&#x27;./static/textures/up.png&#x27;), side: DoubleSide &#125;), new MeshBasicMaterial(&#123; map: textureLoader.load(&#x27;./static/textures/dn.png&#x27;), side: DoubleSide &#125;), new MeshBasicMaterial(&#123; map: textureLoader.load(&#x27;./static/textures/bk.png&#x27;), side: DoubleSide &#125;), new MeshBasicMaterial(&#123; map: textureLoader.load(&#x27;./static/textures/ft.png&#x27;), side: DoubleSide &#125;), ]; const skyboxMesh = new Mesh(skyboxGeometry, skyboxMaterials); skyboxMesh.name = &#x27;skyboxMesh&#x27;; skyboxMesh.position.y = 97.45 this.scene.add(skyboxMesh); loader.load(&#x27;./static/models/glb/RobotExpressive.glb&#x27;, object =&gt; &#123; console.log(object) this.gltf = object this.gltf.scene.position.set(0, -2.5, 0); this.scene.add(this.gltf.scene); this.mixer = new AnimationMixer(this.gltf.scene); this.selectAnim(5, &#x27;点我的身体会有惊喜!&#x27;, true) &#125;); document.getElementById(&#x27;submit&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; this.send() &#125;); document.getElementById(&quot;input&quot;).addEventListener(&quot;keyup&quot;, function (event) &#123; event.preventDefault(); if (event.keyCode === 13) &#123; document.getElementById(&quot;submit&quot;).click(); &#125; &#125;); &#125; private send(): void &#123; let value: string = (&lt;HTMLInputElement&gt;document.getElementById(&#x27;input&#x27;)).value; (&lt;HTMLInputElement&gt;document.getElementById(&#x27;input&#x27;)).value = &quot;&quot; let index = 0 if (/跳舞/.test(value)) &#123; index = 0 &#125; else if (/死/.test(value)) &#123; index = 1 &#125; else if (/闲/.test(value)) &#123; index = 2 &#125; else if (/开心|哈哈|ha/.test(value)) &#123; index = 3 &#125; else if (/生气/.test(value)) &#123; index = 4 &#125; else if (/牛|666/.test(value)) &#123; index = 5 &#125; else if (/你好|hey|hello/.test(value)) &#123; index = 6 &#125; else if (/是|不/.test(value)) &#123; index = 7 &#125; else &#123; index = Math.floor(Math.random() * 9) &#125; switch (index) &#123; case 0: this.selectAnim(0, &#x27;啦~~啦~~~啦~~~&#x27;) break case 1: this.selectAnim(1, &#x27;狗带！&#x27;) break case 2: this.selectAnim(2, &#x27;无所事事。。。&#x27;) break case 3: this.selectAnim(3, &#x27;开心&#x27;) break case 4: this.selectAnim(5, &#x27;好气哦！&#x27;) break case 5: this.selectAnim(9, &#x27;你牛逼！&#x27;) break case 6: this.selectAnim(12, &#x27;你好！&#x27;) break case 7: this.selectAnim(13, &#x27;yes&#x27;) break case 8: this.selectAnim(4, &#x27;你说什么我听不懂？&#x27;) break default: this.selectAnim(4, &#x27;你说什么我听不懂？&#x27;) break; &#125; &#125; private modelTrigger(event): void &#123; const Sx = event.clientX; //鼠标单击位置横坐标 const Sy = event.clientY; //鼠标单击位置纵坐标 //屏幕坐标转标准设备坐标 const x = (Sx / window.innerWidth) * 2 - 1; //标准设备横坐标 const y = -(Sy / window.innerHeight) * 2 + 1; //标准设备纵坐标 //创建射线投射器对象 const raycaster = new Raycaster(); //返回射线选中的对象 raycaster.setFromCamera(new Vector2(x, y), this.camera); const intersects = raycaster.intersectObjects(this.scene.children, true); const intersect = intersects.filter(intersect =&gt; intersect.object.name !== &#x27;skyboxMesh&#x27;) if (intersect.length &gt; 0) &#123; const result = intersect.filter(item =&gt; item.object.name === &#x27;Torso_0&#x27;) if (result.length &gt; 0) &#123; this.selectAnim(5, &#x27;不要乱摸&#x27;) return &#125; switch (intersect[0].object.name) &#123; case &#x27;Head_1&#x27;: this.selectAnim(3, &#x27;摸头杀&#x27;) break case &#x27;Head_2&#x27;: console.log(&#x27;头&#x27;) this.selectAnim(1, &#x27;我的眼睛！！&#x27;) break case &#x27;Torso_1&#x27;: this.selectAnim(12, &#x27;给我捶捶背&#x27;) break case &#x27;FootL&#x27;: this.selectAnim(3, &#x27;左脚可以摸&#x27;) break case &#x27;FootR&#x27;: this.selectAnim(5, &#x27;别碰我的jiong&#x27;) break default: break &#125; &#125; &#125; private selectAnim(index: number, text?: string, loop?: boolean): void &#123; if (this.isAnimate) &#123; return &#125; this.isAnimate = true // animation this.mixer.uncacheClip(this.gltf.animations[this.anindex]) this.animation = this.mixer.clipAction(this.gltf.animations[index]) this.animation.clampWhenFinished = true; //播放完停留在最后一帧 if (!loop) &#123; this.animation.setLoop(LoopOnce, 1) &#125; this.animation.fadeIn(1) this.animation.play() setTimeout(() =&gt; &#123; this.isAnimate = false &#125;, this.gltf.animations[index].duration * 1000); this.anindex = index document.getElementById(&#x27;text&#x27;).innerText = text &#125; //创建场景 private initScene(): void &#123; this.scene = new Scene(); this.scene.position.set(0, 0, 0); this.scene.lookAt(this.scene.position); &#125; //创建相机 private initCamera(): void &#123; this.camera = new PerspectiveCamera( this.fov, this.$window.clientWidth / this.$window.clientHeight, 0.1, 5000 ); this.camera.position.x = this.originalCamera.x this.camera.position.y = this.originalCamera.y this.camera.position.z = this.originalCamera.z this.camera.lookAt(0, 0, 0); &#125; //创建3D渲染器 private initThree(): void &#123; this.renderer = new WebGLRenderer(); this.renderer.setSize( this.$window.clientWidth, this.$window.clientHeight ); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.setClearColor(0xb34149, 1); //设置背景颜色 this.$window.appendChild(this.renderer.domElement); &#125; //创建光源 private initLight(): void &#123; // 环境光 this.scene.add(new AmbientLight(0xd29c96, 1)); // 平行光 let light = new DirectionalLight(0xffffff, 0.6); light.position.set(0, 10, 5); this.scene.add(light); &#125; // 开启控制器 private initControls(): void &#123; this.controls = new OrbitControls(this.camera, this.renderer.domElement); this.controls.enableDamping = true; // 惯性滑动，滑动大小默认0.25 this.controls.dampingFactor = 0.05; // //控制 this.controls.enableZoom = true; // 缩放 this.controls.enableKeys = true; // 键盘 this.controls.enablePan = false; // 是否开启右键拖拽 // 旋转速度 this.controls.rotateSpeed = 1; // 自动旋转 this.controls.autoRotate = false; this.controls.autoRotateSpeed = -0.01; //设置仰视角和俯视角,后续进行重置 this.controls.maxPolarAngle = Math.PI / 2; this.controls.minPolarAngle = Math.PI / 4; this.controls.zoomSpeed = 1; //设置相机距离原点的最远距离 // controls.minDistance = 120; //设置相机距离原点的最远距离 // controls.maxDistance = 120 + 120 * 0.5; &#125; // 创建发光点 private initPulseCircle(): void &#123; this.mainGroup = new Group(); this.scene.add(this.mainGroup); var spriteMap = new TextureLoader().load(&quot;./static/img/img.png&quot;); let pinMaterial = new SpriteMaterial(&#123; map: spriteMap &#125;); this.circleGroup = new Group(); let container = document.createElement(&#x27;div&#x27;) container.className = &#x27;show&#x27; let Div = document.createElement(&#x27;div&#x27;) Div.className = &#x27;text&#x27; Div.id = &quot;text&quot; Div.style.left = 0 + &#x27;px&#x27; Div.style.top = 0 + &#x27;px&#x27; document.body.appendChild(Div) let pin: Sprite = new Sprite(pinMaterial); pin.position.set( this.circleData.x, this.circleData.y, this.circleData.z ); pin.scale.set(0.3, 0.3, 1); this.circleGroup.add(pin); &#125; // 发光点DOM文本 private textShow(): void &#123; let worldVector = new Vector3( this.circleData.x, this.circleData.y, this.circleData.z ); let standardVector = worldVector.project(this.camera); let a = this.$window.clientWidth / 2; let b = this.$window.clientHeight / 2; let x = Math.round(standardVector.x * a + a); let y = Math.round(-standardVector.y * b + b); let Div: HTMLElement = document.getElementById(&#x27;text&#x27;) Div.style.left = x + 30 + &quot;px&quot;; Div.style.top = y + &quot;px&quot;; &#125; private initTrace(): void &#123; const Div: HTMLElement = document.createElement(&#x27;div&#x27;) Div.id = &#x27;trace&#x27; Div.className = &#x27;text&#x27; Div.textContent = &quot;Moon&quot; var moonLabel = new CSS2DObject(Div); moonLabel.position.set(0, -3, 0); this.scene.add(moonLabel); this.labelRenderer = new CSS2DRenderer(); this.labelRenderer.setSize(window.innerWidth, window.innerHeight); this.labelRenderer.domElement.style.position = &#x27;absolute&#x27;; this.labelRenderer.domElement.style.top = 0 + &#x27;px&#x27;; document.body.appendChild(this.labelRenderer.domElement) &#125; private render(): void &#123; window.requestAnimationFrame(() =&gt; this.render()); if (this.mixer) &#123; this.mixer.update(this.clock.getDelta()); &#125; this.controls.update(); this.textShow(); this.renderer.render(this.scene, this.camera); // 必须放在这个位置 this.labelRenderer.render(this.scene, this.camera); &#125; private onWindowResize(): void &#123; this.renderer.setSize(window.innerWidth, window.innerHeight); this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); &#125;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"three.js","slug":"JS/three-js","permalink":"https://hakunamatata052.github.io/categories/JS/three-js/"}],"tags":[{"name":"three.js","slug":"three-js","permalink":"https://hakunamatata052.github.io/tags/three-js/"},{"name":"threejs","slug":"threejs","permalink":"https://hakunamatata052.github.io/tags/threejs/"},{"name":"three","slug":"three","permalink":"https://hakunamatata052.github.io/tags/three/"}]},{"title":"当年的元歌比露娜还秀","slug":"yuange","date":"2020-08-25T08:25:36.000Z","updated":"2020-08-26T07:38:10.000Z","comments":true,"path":"2020/08/25/yuange/","link":"","permalink":"https://hakunamatata052.github.io/2020/08/25/yuange/","excerpt":"","text":"","categories":[{"name":"日常","slug":"日常","permalink":"https://hakunamatata052.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"元歌 王者荣耀","slug":"元歌-王者荣耀","permalink":"https://hakunamatata052.github.io/tags/%E5%85%83%E6%AD%8C-%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/"}]},{"title":"快速搭建webpack4.0+","slug":"webpack","date":"2020-08-25T06:14:00.000Z","updated":"2020-08-25T08:43:38.000Z","comments":true,"path":"2020/08/25/webpack/","link":"","permalink":"https://hakunamatata052.github.io/2020/08/25/webpack/","excerpt":"","text":"初始化npm使用-y来快速创建1npm init -y 安装webpack和webpack-cli脚手架从webpack4.0开始，webpack打包工具和命令行工具就开成两个包了，需要同时安装1npm i webpack webpack-cli -D 创建工程目录新建src目录，之后写的js、html、css等源文件放在这里,在src目录下新建一个index.js作为入口文件src/index.js是webpack默认的入口文件目录，因为不需要单独配置，如果不想使用这个路径，需要在webpack.config.js中单独配置此处目录结构应为 node_modules src index.js package.json 安装webpack-dev-server此时webpack只能每次执行打包命令后才能看到打包结果，开发过程中我们需要实时编译，因此需要一个本地服务1npm i webpack-dev-server -D 安装html-webpack-plugin插件虽然现在可以试试打包js，但是我们的html依然不能进行热更新，而且打包上线时，打包的资源文件一般会进行哈希命名，每次打包手动修改index.html文件中的资源文件名着实很费劲因此需要html-webpack-plugin插件帮我们自动完成资源引用并增加热更新功能1npm i html-webpack-plugin -D安装好后在项目根目录下新建webpack.config.js文件，并设置html-webpack-plugin的对应html模板123456789const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports =&#123; plugins:[ new HtmlWebpackPlugin(&#123; filename:&#x27;index.html&#x27;, template:&quot;./src/index.html&quot; &#125;) ]&#125;在src下新建index.html文件之后目录应为 node_modules src index.js index.html package.json webpack.config.js 新增命令行在package.json的scripts中新增一个命令123456...&quot;scripts&quot;: &#123; &quot;dev&quot;:&quot;webpack-dev-server --host 192.168.0.2 --hot --https --port 80 --open&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125;,...其中--host 192.138.0.2表示配置本地服务的ip--hot表示开启热更新模式--https表示开始https--port 80表示端口为80--open表示启动后自动打开游览器，后面可以跟游览器的标识，不写表示打开默认游览器到此本地服务就搭建完毕了，接下来需要配置loader和打包选项，今天先更到这里","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"webpack","slug":"JS/webpack","permalink":"https://hakunamatata052.github.io/categories/JS/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://hakunamatata052.github.io/tags/webpack/"}]},{"title":"Promise和async/await","slug":"promise","date":"2020-08-25T03:18:00.000Z","updated":"2021-03-12T03:42:42.664Z","comments":true,"path":"2020/08/25/promise/","link":"","permalink":"https://hakunamatata052.github.io/2020/08/25/promise/","excerpt":"为什么要用Promise一般情况我们一次性调用API就可以完成请求。有些情况需要多次调用服务器API，就会形成一个链式调用，比如为了完成一个功能，我们需要调用API1、API2、API3，依次按照顺序进行调用，这个时候就会出现回调地狱的问题 Promise的链式结构使用Promise可以做到链式结构，即一个请求结束后在then方法中执行下一个异步请求，再下一个异步请求放在上一个异步请求的then方法中,但是需要再每个then方法中return一个Promise对象这样我们就得到了一个扁平的结构而不是回调套回调。eg.12345678910111213141516171819202122new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) res() &#125;, 1000);&#125;).then(() =&gt; &#123; return new Promise((res2, rej2) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(2) res2() &#125;, 1000); &#125;)&#125;).then(() =&gt; &#123; return new Promise((res3, rej4) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(3) res3() &#125;, 1000); &#125;)&#125;).then(() =&gt; &#123; console.log(&#x27;结束&#x27;)&#125;)","text":"为什么要用Promise一般情况我们一次性调用API就可以完成请求。有些情况需要多次调用服务器API，就会形成一个链式调用，比如为了完成一个功能，我们需要调用API1、API2、API3，依次按照顺序进行调用，这个时候就会出现回调地狱的问题 Promise的链式结构使用Promise可以做到链式结构，即一个请求结束后在then方法中执行下一个异步请求，再下一个异步请求放在上一个异步请求的then方法中,但是需要再每个then方法中return一个Promise对象这样我们就得到了一个扁平的结构而不是回调套回调。eg.12345678910111213141516171819202122new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) res() &#125;, 1000);&#125;).then(() =&gt; &#123; return new Promise((res2, rej2) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(2) res2() &#125;, 1000); &#125;)&#125;).then(() =&gt; &#123; return new Promise((res3, rej4) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(3) res3() &#125;, 1000); &#125;)&#125;).then(() =&gt; &#123; console.log(&#x27;结束&#x27;)&#125;)执行结果是1234123结束 使用all方法但是通常在真是项目中，每个请求会有单独的方法封装，而且每个Promise会有独立的then方法，这时可以使用Promise对象的all方法他表示无论三个异步请求谁先执行谁后执行，都等待三个异步请求全部结束后执行all中的函数。如果后一个请求需要得到前一个请求中的数据，那么还是需要使用前面的链式结构才行。如果既要使用已经封装好的Promise函数，有需要按步调用，可以使用ES7中的async/awaiteg.123456789101112131415161718192021const promise1 = new Promise((res, rej)=&gt;&#123; setTimeout(() =&gt; &#123; console.log(1) res() &#125;, 1000);&#125;)const promise2 = new Promise((res, rej)=&gt;&#123; setTimeout(() =&gt; &#123; console.log(2) res() &#125;, 3000);&#125;)const promise3 = new Promise((res, rej)=&gt;&#123; setTimeout(() =&gt; &#123; console.log(3) res() &#125;, 2000);&#125;)Promise.all([promise1, promise2, promise3]).then(()=&gt; &#123; console.log(&#x27;结束&#x27;);&#125;);执行结果是1234132结束 async/await首先封装的方法需要return一个Promise对象，接着在请求的函数前面添加async关键字，在请求函数的内部使用变量或常量接受封装的Promise对象即可，但是封装的Promise对象前需要加await这时接收到的结果就是Promise对象中then方法中return的结果1234567891011121314151617function ajax()&#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(() =&gt; &#123; resolve(&quot;666&quot;) &#125;, 5000); &#125;).then(res=&gt;&#123; return res &#125;)&#125;async function ajaxAsync()&#123; console.log(1) const r = await ajax() console.log(2) console.log(r) console.log(3)&#125;ajaxAsync()执行结果是123412 // 5s后6663","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"}],"tags":[{"name":"Promise async/await async await 同步异步 异步","slug":"Promise-async-await-async-await-同步异步-异步","permalink":"https://hakunamatata052.github.io/tags/Promise-async-await-async-await-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5-%E5%BC%82%E6%AD%A5/"}]},{"title":"Three.js 入门","slug":"three.js","date":"2020-08-24T08:21:00.000Z","updated":"2020-08-26T07:39:40.000Z","comments":true,"path":"2020/08/24/three.js/","link":"","permalink":"https://hakunamatata052.github.io/2020/08/24/three.js/","excerpt":"安装three.js使用npm安装three.js1npm i three -S导入场景、相机、灯光、渲染器等类1import &#123; Scene, PerspectiveCamera, WebGLRenderer ,AmbientLight ,DirectionalLight&#125; from &quot;three&quot;创建并暴露一个类，定义场景、相机、灯光等，并设置渲染的DOM容器","text":"安装three.js使用npm安装three.js1npm i three -S导入场景、相机、灯光、渲染器等类1import &#123; Scene, PerspectiveCamera, WebGLRenderer ,AmbientLight ,DirectionalLight&#125; from &quot;three&quot;创建并暴露一个类，定义场景、相机、灯光等，并设置渲染的DOM容器 123456789export class Three &#123; private scene: Scene private camera: PerspectiveCamera private renderer: WebGLRenderer private $window: HTMLElement constructor() &#123; this.$window = document.querySelector(&quot;#app&quot;); &#125;&#125; 创建场景初始化一个场景,这里我设置了一个私有方法，之后会在constructor中调用scene.position.set可以设置场景在坐标系的位置123456//创建场景private initScene(): void &#123; this.scene = new Scene(); this.scene.position.set(0, 0, 0); this.scene.lookAt(this.scene.position);&#125; 创建相机接着初始化相机,这里使用的是透视相机PerspectiveCamera，相机接受4个参数，分别是 PerspectiveCamera(fov, aspect, near, far) Fov – 相机的视锥体的垂直视野角 Aspect – 相机视锥体的长宽比 Near – 相机视锥体的近平面 Far – 相机视锥体的远平面相机的位置可以使用camera.position.x，camera.position.y，camera.position.z进行赋值来改变12345678910//创建相机private initCamera(): void &#123; this.camera = new PerspectiveCamera( 25, this.$window.clientWidth / this.$window.clientHeight, 0.1, 1000 ); this.camera.lookAt(0, 0, 0);&#125; 创建光源接着初始化灯光,这里添加了两个灯光，一个环境光，一个平行光，可添加多个光源灯光的构造函数中传入灯光颜色和透明度，颜色必须是0x+16进制色环境光没有位置属性，平行光可以添加光源的位置，使用light.position.set来设置位置，传入三个参数分别是x坐标，y坐标，z坐标123456789//创建光源private initLight(): void &#123; // 环境光 this.scene.add(new AmbientLight(0xd29c96, 1)); // 平行光 let light = new DirectionalLight(0xffffff, 0.6); light.position.set(0, 10, 5); this.scene.add(light);&#125; 创建3D渲染器接着创建渲染器,使用three内置的WebGLRenderer渲染器来渲染，渲染器可以通过setSize方法设置大小，这里我们设置一个和画布一样大的渲染器，如果渲染尺寸小于画布大小，则超出渲染器大小的位置将不被渲染使用setClearColor方法可以设置渲染区域的背景色最后将渲染器的domElement属性appendChild进需要的DOM标签内即可12345678910//创建3D渲染器private initThree(): void &#123; this.renderer = new WebGLRenderer(); this.renderer.setSize( this.$window.clientWidth, this.$window.clientHeight ); this.renderer.setClearColor(0xb34149, 1); //设置背景颜色 this.$window.appendChild(this.renderer.domElement);&#125; 接着将这些方法添加进constructor内，让实例创建时自动执行123456789101112export class Three &#123; private scene: Scene private camera: PerspectiveCamera private renderer: WebGLRenderer private $window: HTMLElement constructor() &#123; this.$window = document.querySelector(&quot;#app&quot;); this.initScene(); this.initThree(); this.initCamera(); &#125;&#125; 开启控制器接着使用renderer.render方法就可以渲染了，但是这样只能渲染一帧画面，我们需要做鼠标控制，或者3D动画是需要实时渲染的例如加一个鼠标控制首先导入控制器1import &#123; OrbitControls &#125; from &#x27;three/examples/jsm/controls/OrbitControls&#x27;; 接着初始化这个控制器，这里依然使用一个方法,然后添加进constructor123456789101112131415161718192021222324252627// 开启控制器private initControls(): void &#123; this.controls = new OrbitControls(this.camera, this.renderer.domElement); this.controls.enableDamping = true; // 惯性滑动，滑动大小默认0.25 this.controls.dampingFactor = 0.05; // //控制 this.controls.enableZoom = false; // 缩放 this.controls.enableKeys = false; // 键盘 this.controls.enablePan = false; // 是否开启右键拖拽 // 旋转速度 this.controls.rotateSpeed = 1; // 自动旋转 this.controls.autoRotate = false; this.controls.autoRotateSpeed = -0.01; //设置仰视角和俯视角,后续进行重置 this.controls.maxPolarAngle = Math.PI / 2; this.controls.minPolarAngle = Math.PI / 4; this.controls.zoomSpeed = 1; //设置相机距离原点的最远距离 // controls.minDistance = 120; //设置相机距离原点的最远距离 // controls.maxDistance = 120 + 120 * 0.5;&#125; 渲染这样添加的控制器虽然可以控制场景，但是画布不会重新渲染，所以我们需要添加一个渲染函数并且每次调用自身来更新画面这里使用的是requestAnimationFrame函数来调用自身，也可以使用setInterval但是setInterval是固定时间渲染，如果场景过大，过复杂，可能时间到了还没渲染好又得渲染下一帧，这样会导致页面卡死requestAnimationFrame没有固定时间，他会在当前帧渲染完毕后执行下一次，这样就不会导致页面卡死了接着在render方法中使用controls.update()来更新每次的控制，使用renderer.render来更新画面最后在constructor函数中调用render即可12345private render(): void &#123; window.requestAnimationFrame(() =&gt; this.render()); this.controls.update(); this.renderer.render(this.scene, this.camera);&#125; 最后在需要需要的地方导入并new Three()就可以了 效果","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"three.js","slug":"JS/three-js","permalink":"https://hakunamatata052.github.io/categories/JS/three-js/"}],"tags":[{"name":"three.js","slug":"three-js","permalink":"https://hakunamatata052.github.io/tags/three-js/"},{"name":"threejs","slug":"threejs","permalink":"https://hakunamatata052.github.io/tags/threejs/"},{"name":"three","slug":"three","permalink":"https://hakunamatata052.github.io/tags/three/"}]},{"title":"制作菱形图片遮罩","slug":"mark","date":"2019-03-01T02:56:52.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2019/03/01/mark/","link":"","permalink":"https://hakunamatata052.github.io/2019/03/01/mark/","excerpt":"方法一使用box-shadow制作菱形遮罩 需要在原有结构内增加一个shaow遮罩层 HTML1234&lt;div class=&quot;img&quot;&gt; &lt;img src=&quot;https://picsum.photos/300/300&quot;&gt; &lt;div class=&quot;shadow&quot;&gt;&lt;/div&gt;&lt;/div&gt;","text":"方法一使用box-shadow制作菱形遮罩 需要在原有结构内增加一个shaow遮罩层 HTML1234&lt;div class=&quot;img&quot;&gt; &lt;img src=&quot;https://picsum.photos/300/300&quot;&gt; &lt;div class=&quot;shadow&quot;&gt;&lt;/div&gt;&lt;/div&gt; 外层div设置相对定位position: relative;将shadow层旋转45度，并设置阴影；box-shadow中的值分别是：box-shadow：水平位移 垂直位移 阴影宽度 模糊程度 颜色这里水平和垂直位移这只为0，即从中间开始向四周出现阴影。 阴影宽度一定要宽于外框，模糊程度可以填0，即不模糊，颜色填白色。 CSS1234567891011121314151617181920.img &#123; width: 300px; height: 300px; position: relative; margin: 100px auto; overflow: hidden;&#125;.shadow &#123; width: 200px; height: 200px; box-shadow: 0px 0px 0px 200px #fff; transform: rotate(45deg); position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: -100px; border-radius: 10px;&#125; 效果 方法二使用两次旋转达到菱形效果 HTML123&lt;div class=&quot;img&quot;&gt; &lt;img src=&quot;https://picsum.photos/300/300&quot;&gt;&lt;/div&gt; CSS1234567891011121314151617181920212223242526.img &#123; position: relative; width:200px; height: 200px; margin: 50px auto; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); border-radius: 10px; overflow: hidden;&#125;.img img &#123; position: absolute; left: 50%; top: 50%; display: block; width: 500px; height: 500px; margin-top: -250px; margin-left: -250px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg);&#125; 效果","categories":[{"name":"CSS","slug":"CSS","permalink":"https://hakunamatata052.github.io/categories/CSS/"}],"tags":[{"name":"CSS CSS3","slug":"CSS-CSS3","permalink":"https://hakunamatata052.github.io/tags/CSS-CSS3/"}]},{"title":"科学上网（翻墙）神器【蓝灯】","slug":"lantern","date":"2019-01-21T01:08:46.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2019/01/21/lantern/","link":"","permalink":"https://hakunamatata052.github.io/2019/01/21/lantern/","excerpt":"给大家介绍一款免费限制流量的科学上网神器蓝灯lantren下载地址：Github里面包含Windows，Android，macOS三个版本。点击对应拓展名文件进入下载即可","text":"给大家介绍一款免费限制流量的科学上网神器蓝灯lantren下载地址：Github里面包含Windows，Android，macOS三个版本。点击对应拓展名文件进入下载即可 以Windows为例点击3.0最新版的exe文件 点击download下载 下载先来后双击安装即可。速度还可以~~ 每个月有500MB的免费流量，可以升级到专业版，不限制流量。博主500MB基本足够。而且他采用的是只能切换线路，如果访问的是国内站点，是不通过VPN的，也不会消耗流量。只有当你访问被墙网站的时候才会切换vpn线路。","categories":[],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://hakunamatata052.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"翻墙","slug":"翻墙","permalink":"https://hakunamatata052.github.io/tags/%E7%BF%BB%E5%A2%99/"}]},{"title":"一句代码解决bootstrap栅格几个设置5等分","slug":"bootstrap-offset","date":"2019-01-04T07:45:01.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2019/01/04/bootstrap-offset/","link":"","permalink":"https://hakunamatata052.github.io/2019/01/04/bootstrap-offset/","excerpt":"","text":"HTML123456789&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;li class=&quot;col-xs-offset-1 col-xs-2 text-center&quot;&gt;苹果&lt;/li&gt; &lt;li class=&quot;col-xs-2 text-center&quot;&gt;香蕉&lt;/li&gt; &lt;li class=&quot;col-xs-2 text-center&quot;&gt;番茄&lt;/li&gt; &lt;li class=&quot;col-xs-2 text-center&quot;&gt;石榴&lt;/li&gt; &lt;li class=&quot;col-xs-2 text-center&quot;&gt;芒果&lt;/li&gt; &lt;/div&gt;&lt;/div&gt;正常设置每个栅格2等分，最后会在末尾空余出2等分（共12等分），然后第一个栅格设置col-xs-offset-1，意思是偏移一格，等于把最后的2等分其中一份放在最前面了。这样做可以解决bootstrap栅格5等分的问题，但是最终宽度会比正常窄，可以单独设置container的宽来解决。","categories":[{"name":"HTML","slug":"HTML","permalink":"https://hakunamatata052.github.io/categories/HTML/"},{"name":"BOOTSTRAP","slug":"HTML/BOOTSTRAP","permalink":"https://hakunamatata052.github.io/categories/HTML/BOOTSTRAP/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://hakunamatata052.github.io/tags/bootstrap/"},{"name":"offset","slug":"offset","permalink":"https://hakunamatata052.github.io/tags/offset/"}]},{"title":"This is dobby!","slug":"dobby","date":"2019-01-03T09:22:09.000Z","updated":"2020-08-26T07:38:04.000Z","comments":true,"path":"2019/01/03/dobby/","link":"","permalink":"https://hakunamatata052.github.io/2019/01/03/dobby/","excerpt":"","text":"这就是Dobby Orz.","categories":[{"name":"日常","slug":"日常","permalink":"https://hakunamatata052.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"如何使用fonts.googleapis.com使自己的网站增加更多字体","slug":"fonts-googleapis","date":"2019-01-02T09:04:17.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2019/01/02/fonts-googleapis/","link":"","permalink":"https://hakunamatata052.github.io/2019/01/02/fonts-googleapis/","excerpt":"首先，fonts.googleapis.com解决的是客户端电脑没有安装字体，但是网站主又想客户看到自己想要的字体，通常的做法就是网站的css调用网站内部的字体文件，但是这样做非常不灵活，我们需要更换字体时，不然需要修改css，还需要替换字体文件，于是fonts.googleapis.com就可以解决这个问题。","text":"首先，fonts.googleapis.com解决的是客户端电脑没有安装字体，但是网站主又想客户看到自己想要的字体，通常的做法就是网站的css调用网站内部的字体文件，但是这样做非常不灵活，我们需要更换字体时，不然需要修改css，还需要替换字体文件，于是fonts.googleapis.com就可以解决这个问题。 使用方法CSS引入1&lt;link href=&quot;//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;subset=latin,latin-ext&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;链接的具体构成就是：fonts.googleapis.com/css?family=字体名称:加粗程度,加粗程度+是否斜体&amp;subset=latin,latin-ext其中如果需要多种字体用 | 隔开，如果有多种加粗程度最后在需要使用的元素上加入font-family属性即可1234body &#123; font-family: &#x27;Monda&#x27;, &#x27;PT Mono&#x27; , serif; font-size: 48px;&#125; fonts.googleapis.com还有一种ajax请求方式，这里不推荐使用，css是最快也最容易维护的方式。","categories":[{"name":"HTML","slug":"HTML","permalink":"https://hakunamatata052.github.io/categories/HTML/"}],"tags":[{"name":"googleapis","slug":"googleapis","permalink":"https://hakunamatata052.github.io/tags/googleapis/"},{"name":"字体","slug":"字体","permalink":"https://hakunamatata052.github.io/tags/%E5%AD%97%E4%BD%93/"}]},{"title":"Hexo添加置顶功能和标识","slug":"hexo-top","date":"2018-12-29T09:29:09.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/29/hexo-top/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/29/hexo-top/","excerpt":"首先看下效果","text":"首先看下效果 具体实现安装插件12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 新建/修改 文章新建或修改文章时在文章Front-matter中加入top: true即可123456789---title: 无JS实现在线客服的切换效果date: 2018-12-20 15:05:17tags: - css - css3categories: CSStop: true--- 到此为止，文章的置顶功能就实现了,但是我们还需要给置顶的文章加个标识，如So，我们需要加一个图标或者文字标签这里我做了一个简单的，你可以修改一下，做一个好看的图标 添加标识如果你使用的是next的主题，打开目录themes/next/layout/_macro，找到文件post.swig，搜索1&lt;/&#123;% if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;大概在65行，在他上面添加123&#123;% if post.top %&#125; &lt;span style=&quot;color:#f00;border:1px solid #f00;padding:2px 5px;font-size:12px;&quot;&gt;置顶&lt;/span&gt;&#123;% endif %&#125;这是你会发现标识出现了，但是高度有些错位，在themes/next/source/_custom中找到custom.styl文件，添加一行123.posts-expand .post-title &#123; line-height:1&#125;这时你就可以看到具体的效果了 当然你可以添加更好看的图标，只需要修改HTML和CSS即可。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://hakunamatata052.github.io/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hakunamatata052.github.io/tags/Hexo/"},{"name":"next","slug":"next","permalink":"https://hakunamatata052.github.io/tags/next/"}]},{"title":"利用iconfont.cn快速制作前端图标","slug":"iconfont","date":"2018-12-22T02:28:36.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/22/iconfont/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/22/iconfont/","excerpt":"以前不会用iconfont.cn的时候，只知道这是个图标库，可以吧图片下载下来，然后制作成图片，在写入HTML。其实没有这么麻烦，iconfont支持三种图片引入方式——Unicode，字体，svg","text":"以前不会用iconfont.cn的时候，只知道这是个图标库，可以吧图片下载下来，然后制作成图片，在写入HTML。其实没有这么麻烦，iconfont支持三种图片引入方式——Unicode，字体，svg 注册账号首先登录iconfont 这里我使用的是Github账号直接登录，你可以使用微博账号登录 搜索图标然后再首页搜索你需要的图标，可以使用中文搜索（建议英文） 找到想要的图标之后不要点击下载按钮，要点击购物车按钮，这样才能将多个图片集合到一个项目里 通常一个项目或网站肯定不止一个图，这时你可以继续搜素其他图标并加入购物车当你需要将所有图标制作成网站需要的字体文件或者svg文件引入时，点击右上角的购物车按钮 这里的三个选项分别是： 名称 解释 添加至项目 添加到新建或已有的项目（后期可继续添加图标） 下载素材 下载购物车里的图标素材，最后可以下载AI，SVG,PNG格式的图片文件 下载代码 下载生成的引入文件 包含CSS，font，svg等，与添加项目类似，但是后期无法继续添加图标 这里为了后期能够继续增加或删除图标，我们尽量选择添加至项目，如果没有项目，他会提示你新建项目，根据提示操作就好，这里不再赘述。 引用图标制作好的图标可以在我的项目中看到,可以选择引用iconfont的远程地址（CDN方式），也可以下载到本地引入，如果是使用CDN方式，需要依次点击查看在线链接–生成链接 Unicode方式需要在你的css中加入上面的代码12345678@font-face &#123; font-family: &#x27;iconfont&#x27;; /* project id 978636 */ src: url(&#x27;//at.alicdn.com/t/font_978636_9jco6oz9c8i.eot&#x27;); src: url(&#x27;//at.alicdn.com/t/font_978636_9jco6oz9c8i.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;//at.alicdn.com/t/font_978636_9jco6oz9c8i.woff&#x27;) format(&#x27;woff&#x27;), url(&#x27;//at.alicdn.com/t/font_978636_9jco6oz9c8i.ttf&#x27;) format(&#x27;truetype&#x27;), url(&#x27;//at.alicdn.com/t/font_978636_9jco6oz9c8i.svg#iconfont&#x27;) format(&#x27;svg&#x27;);&#125;如果某个地方需要使用图标，HTML和CSS分别是这样 HTML123&lt;div class=&quot;dome&quot;&gt; &amp;#xe654;&lt;/div&gt; css123.dome&#123; font-family: &#x27;iconfont&#x27;;&#125; 这里的&amp; # x e 6 5 4;就是图标对应代码 Font classfont class是一个链接，需要用link引入 html12&lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_978636_9jco6oz9c8i.css&quot;&gt;&lt;div class=&quot;dome&quot;&gt;&lt;/div&gt; css123.dome&#123; font-family: &#x27;iconfont&#x27;;&#125; symbol引用拷贝项目下面生成的symbol代码： HTML1//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js 加入通用css代码： css123456.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; &#125; 挑选相应图标并获取类名，应用于页面 html123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 这里的#icon-XXX对应图标代码 如icon-menu 最后，墙裂建议使用Font class方式引入，兼容度最高，图标大小可以通过font-size控制，颜色可以通过color控制，很方便。","categories":[{"name":"HTML","slug":"HTML","permalink":"https://hakunamatata052.github.io/categories/HTML/"}],"tags":[{"name":"inconfont","slug":"inconfont","permalink":"https://hakunamatata052.github.io/tags/inconfont/"},{"name":"图标","slug":"图标","permalink":"https://hakunamatata052.github.io/tags/%E5%9B%BE%E6%A0%87/"}]},{"title":"利用Github上传并引用video资源","slug":"github-video","date":"2018-12-21T07:56:58.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/21/github-video/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/21/github-video/","excerpt":"很多网站都有背景视频的元素，利用的是【HTML5】的新特性————【video】标签例如：点击打开 里面的banner背景，就是一个视频","text":"很多网站都有背景视频的元素，利用的是【HTML5】的新特性————【video】标签例如：点击打开 里面的banner背景，就是一个视频 具体代码：123&lt;video src=&quot;video.mp4&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持 video 标签。&lt;/video&gt;但是对于很多服务器来说，视频太站资源，太耗流量，但是将视频上传到优酷、腾讯视频上又无法获得视频真实地址（video标签中的视频必须是视频的物理地址，即必须以.mp4等的拓展名结束的地址），而且还有广告这里推荐一个简单的方法： 使用GitHub等git托管网站上传视频 方法注册首先注册一个GitHub账号 点我注册 新建项目点击New新建一个项目，名称可以随便取，但是不能写中文,填写好后点击【Create repository】 需要注意的是 必须选中Initialize this repository with a README这个选项，否则你需要安装git使用指令将视频传上去。 上传视频新建号项目你将看到这样的界面，点击【Upload files】上传你的视频就可以，最后上传完了之后点击【Commit changes】 引用视频上传完毕后就能在项目中看到你的视频，点击视频后再复制【View Raw】的连接就可以获得视频的真实地址了，例如我的连接是：https://github.com/HakunaMatata052/video/blob/master/a.mp4?raw=true注意：视频最后的 ?raw=true 不能删除，否则视频无法播放 最后放在代码里看一下123&lt;video src=&quot;https://github.com/HakunaMatata052/video/blob/master/a.mp4?raw=true&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持 video 标签。&lt;/video&gt; 效果： 您的浏览器不支持 video 标签。 如果想让视频当背景用的话，需要设video为自动播放，可以设置autoplay=”autoplay”具体代码如下 123&lt;video src=&quot;https://github.com/HakunaMatata052/video/blob/master/a.mp4?raw=true&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot;&gt;您的浏览器不支持 video 标签。&lt;/video&gt; 如果需要隐藏播放控件可以去掉 controls=”controls” ，也可以使用css123video::-webkit-media-controls &#123; display:none !important;&#125;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://hakunamatata052.github.io/categories/HTML/"}],"tags":[{"name":"github","slug":"github","permalink":"https://hakunamatata052.github.io/tags/github/"}]},{"title":"Vue全局公用函数","slug":"vue-global-function","date":"2018-12-21T03:00:29.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/21/vue-global-function/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/21/vue-global-function/","excerpt":"经常在做项目的时候会遇到一个函数在很多组件和页面中调用，如计算时间差，刷新token等操作，这时就需要定义一个全局都能调用的函数","text":"经常在做项目的时候会遇到一个函数在很多组件和页面中调用，如计算时间差，刷新token等操作，这时就需要定义一个全局都能调用的函数 新建js文件可以放在src的utils文件中，命名index.js 12345exports.install = function (Vue, options) &#123; Vue.prototype.changeData = function ()&#123; alert(&#x27;执行成功&#x27;); &#125;;&#125;; 调用函数在需要调用函数的组件内引入Vue和该函数文件 123import Vue from &#x27;vue&#x27; //引入Vueimport base from &#x27;../../utils&#x27; //引入新建的公用函数jsVue.use(base); //使用新建的公用函数js 如果需要全局引用，则将调用函数写在main.js中即可","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"VUE","slug":"JS/VUE","permalink":"https://hakunamatata052.github.io/categories/JS/VUE/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://hakunamatata052.github.io/tags/vue/"}]},{"title":"无JS实现在线客服的切换效果","slug":"nojs-toggle","date":"2018-12-20T07:05:17.000Z","updated":"2020-08-25T06:12:08.000Z","comments":true,"path":"2018/12/20/nojs-toggle/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/20/nojs-toggle/","excerpt":"首先可以看下效果点我查看 这里利用HTML的 【checkbox】类型的【input】和【label】元素的【for】属性和CSS的【:checked】选择器以及【~】选择器 主要的原理是点击【label】使【label】的【for】属性指定id【input】改变选中状态（【:checked】），【input】选中状态改变后，使用css改变【input】后面的元素的显示或隐藏（或定位）。","text":"首先可以看下效果点我查看 这里利用HTML的 【checkbox】类型的【input】和【label】元素的【for】属性和CSS的【:checked】选择器以及【~】选择器 主要的原理是点击【label】使【label】的【for】属性指定id【input】改变选中状态（【:checked】），【input】选中状态改变后，使用css改变【input】后面的元素的显示或隐藏（或定位）。 首先你必须知道元素的for属性可以控制【checkbox】类型的【input】 例如： 123&lt;input type=&quot;checkbox&quot; id=&quot;dome&quot;&gt;&lt;label for=&quot;dome&quot;&gt;切换&lt;/label&gt; 效果: 然后利用CSS的 ~ 选择器 设置input被选中后紧跟的元素的样式 多提一句~ 选择器表示元素后的同胞元素如：123p~ul&#123; background:#ff0000;&#125;123456&lt;p&gt;快乐生活&lt;/p&gt;&lt;ul&gt; &lt;li&gt;生活&lt;/li&gt; &lt;li&gt;生活&lt;/li&gt; &lt;li&gt;生活&lt;/li&gt;&lt;/ul&gt;会给p元素后所有的ul元素加背景 那么我们需要做的就是为input后的元素做隐藏显示（或改变定位）如何判断需要显示还是隐藏呢？需要用到input的checked属性 如果需要改变默认状态可以给input加checked=”checked” 最后具体代码如下HTML1234567891011&lt;div class=&quot;dome&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;toggle&quot;&gt; &lt;div class=&quot;open&quot;&gt; &lt;label for=&quot;toggle&quot;&gt;关闭&lt;/label&gt; 打开以后你看到的 &lt;/div&gt; &lt;div class=&quot;close&quot;&gt; &lt;label for=&quot;toggle&quot;&gt;打开&lt;/label&gt; 关闭以后你看到的 &lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718#toggle &#123; display:none;&#125;#toggle~.open &#123; display:block;&#125;#toggle~.close &#123; display:none;&#125;#toggle:checked~.open &#123; display:none;&#125;#toggle:checked~.close &#123; display:block;&#125; 效果：","categories":[{"name":"CSS","slug":"CSS","permalink":"https://hakunamatata052.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://hakunamatata052.github.io/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://hakunamatata052.github.io/tags/css3/"}]},{"title":"javascript思维导图","slug":"js-mind-map","date":"2018-12-20T00:40:43.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/20/js-mind-map/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/20/js-mind-map/","excerpt":"下面附上十张javascript思维导图，如果把里面的内容全部掌握，那就是高手了。思维导图提供给我们一个整体的知识体系，也可以说是一种工具，废话不多说，上图：","text":"下面附上十张javascript思维导图，如果把里面的内容全部掌握，那就是高手了。思维导图提供给我们一个整体的知识体系，也可以说是一种工具，废话不多说，上图： javascript数据类型 javascript数组 javascript运算符 javascript正则表达式 javascript字符串函数 window对象 DOM基本操作 javascript变量 javascript函数基础 javascript流程控制 本文转自咸鱼老弟https://www.cnblogs.com/xianyulaodi/p/5886128.html","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"}],"tags":[{"name":"js","slug":"js","permalink":"https://hakunamatata052.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"https://hakunamatata052.github.io/tags/javascript/"}]},{"title":"PNG格式小图标的CSS任意颜色赋色技术","slug":"css3-add-color","date":"2018-12-19T09:50:12.000Z","updated":"2022-01-01T08:15:25.449Z","comments":true,"path":"2018/12/19/css3-add-color/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/19/css3-add-color/","excerpt":"PNG格式小图标的CSS任意颜色赋色技术**注意**：PC某些浏览器不支持，请勿使用，手机端可以使用","text":"PNG格式小图标的CSS任意颜色赋色技术**注意**：PC某些浏览器不支持，请勿使用，手机端可以使用 主要代码1filter: drop-shadow(rgb(62, 243, 52) 20px 0px); 实现原理原理其实很简单，使用了CSS3滤镜filter中的drop-shadow，drop-shadow滤镜可以给元素或图片非透明区域添加投影。 如果对drop-shadow不是很了解，建议先看看前些时间写的“CSS3 filter:drop-shadow滤镜与box-shadow区别应用”一文！ 对于背景透明的png小图标而言，如果我们施加一个不带模糊的投影，不就等同于生成了另外一个颜色的小图标了吗？ 然后，我们把原始图标隐藏在容器外面，投影图标在容器中间，不见给人感觉是赋色效果了？ 比方说本文的demo，如果把icon父级的的 overflow:hidden 去掉，原始的图标就暴露出来啦！ 具体代码HTML123&lt;i class=&quot;icon&quot;&gt; &lt;i class=&quot;icon icon-del&quot;&gt;&lt;/i&gt;&lt;/i&gt; 1234567891011121314 .icon &#123; /*图标元素必须是块级元素，有宽高，切必须溢出隐藏*/ display: inline-block; width: 20px; height: 20px; overflow: hidden;&#125;.icon &gt; .icon &#123; position: relative; left: -20px; /*-20px为图标宽度，必须是负值*/ border-right: 20px solid transparent; -webkit-filter: drop-shadow(rgb(62, 243, 52) 20px 0px); /*20px为图标宽度*/ filter: drop-shadow(rgb(62, 243, 52) 20px 0px); /*20px为图标宽度*/ background: url(delete.png) no-repeat center; /*图标png文件设置在包裹内的div中切必须是块级元素，有宽高*/&#125; 兼容性IE13+支持，Chrome和FireFox浏览器支持，移动端iOS支持，Android4.4+支持。也就是，基本上，移动端现在可以使用这种技术了。既节约了流量，也让我们的开发更简单，维护更方便了。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://hakunamatata052.github.io/categories/CSS/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://hakunamatata052.github.io/tags/css3/"}]},{"title":"css3曲线投影","slug":"css3-curve-shadow","date":"2018-12-19T09:38:12.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/19/css3-curve-shadow/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/19/css3-curve-shadow/","excerpt":"模仿纸张曲线投影效果展示","text":"模仿纸张曲线投影效果展示 实现原理首先，曲线投影的终效果其实是多投影重叠的效果：一点点倾斜的投影重叠一个直直的投影。一般的直来直往的投影显然是使用box-shadow属性就可以搞定了。至于那个倾斜的投影，如果是现代浏览器，则需要就是CSS3变换属性transform（具体参见之前的“CSS3 Transitions, Transforms和Animation使用简介与应用展示”一文）。首先是倾斜，5度左右的样子，然后让其在主投影的后面显示就可以了。然后，单单只有倾斜是不够的，因为有一个脚会从一侧露出来，这很好理解。假设两个矩形一样大，位置完全重叠，如果发生旋转，则必定有边角不重合而露出来。即使矩形尺寸不一样，只要其以一个公共的边角旋转，至少会有两个角露出来，而实际上我们只需要一个，也就是斜边投影的哪个角。那么这个问题该如何解决呢，也很简单，同样是transform，不过这回不是旋转，而是拉伸(skew)，将规整的矩形拉伸成平行四边形，可避免旋转的时候多余的角露出来。 对于不支持CSS3的IE浏览器，按照上面的原理，理论上也是可以模拟出曲线投影效果的。因为IE下的投影效果可以使用投影滤镜（效果生硬不推荐）实现，或是模糊滤镜实现（推荐），至于旋转也有旋转滤镜。但是，就性能和成本而言，是否应该使用很值得商榷。 具体代码HTML12&lt;div class=&quot;img&quot;&gt;&lt;/div&gt;&lt;!-- 图片的宽高可以在CSS里更改 --&gt; CSS1234567891011121314151617181920212223242526272829303132333435363738394041.img &#123; display: inline-block; *display: inline; width: 200px; height: 248px; margin: 20px; background-color: #fff; border: 1px solid #eee; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 60px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; position: relative; *zoom: 1;&#125;.img:before &#123; -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg); left: 15px;&#125;.img:after &#123; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg); right: 15px;&#125;.img:before, .img:after &#123; width: 70%; height: 55%; content: &#x27; &#x27;; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); position: absolute; bottom: 10px; z-index: -1; &#125; 友情提示这里的斜边投影使用的是负值z-index定位到本体阴影的后面的。由于使用的是z-index负值，所以，请务必保证当前投影元素的所有父标签均没有背景图片或背景色（body标签除外），否则，斜边投影是看不到的。 原文链接CSS3 box-shadow实现纸张的曲线投影效果","categories":[{"name":"CSS","slug":"CSS","permalink":"https://hakunamatata052.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://hakunamatata052.github.io/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://hakunamatata052.github.io/tags/css3/"}]},{"title":"jQueryAjax请求完全版","slug":"jquery-ajax","date":"2018-12-19T09:34:07.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/19/jquery-ajax/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/19/jquery-ajax/","excerpt":"","text":"jQueryAjax请求完全版12345678910111213141516171819202122232425$.ajax(&#123; async: true, //true异步，false同步 url: &#x27;/uploads/rs/419/nvhogkww/data.json&#x27;, type: &#x27;get&#x27;, complete: function(XHR, TS) &#123; alert(&#x27;complete&#x27;); &#125;, //完成回调函数(XHR, TS) error: function(XMLHttpRequest, textStatus, errorThrown) &#123; //XMLHttpRequest.readyState: //0 － （未初始化）还没有调用send()方法 //1 － （载入）已调用send()方法，正在发送请求 //2 － （载入完成）send()方法执行完成，已经接收到全部响应内容 //3 － （交互）正在解析响应内容 //4 － （完成）响应内容解析完成，可以在客户端调用了 //XMLHttpRequest.status: //textStatus: &quot;timeout&quot;, &quot;error&quot;, &quot;notmodified&quot; 和 &quot;parsererror&quot;。 //（0）null //（1）timeout 超时 //（2）error //（3）notmodified 未修改 //（4）parsererror 解析错误 console.log(&#x27;错误1：&#x27; + XMLHttpRequest.readyState); console.log(&#x27;错误2：&#x27; + textStatus); console.log(&#x27;错误3：&#x27; + errorThrown); &#125;, //默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。 success: function(response) &#123; alert(&#x27;success&#x27;); &#125;&#125;);","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"jQuery","slug":"JS/jQuery","permalink":"https://hakunamatata052.github.io/categories/JS/jQuery/"}],"tags":[{"name":"js","slug":"js","permalink":"https://hakunamatata052.github.io/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"https://hakunamatata052.github.io/tags/jquery/"}]},{"title":"Vuex的使用","slug":"vuex","date":"2018-12-19T08:25:36.000Z","updated":"2020-08-25T09:28:46.000Z","comments":true,"path":"2018/12/19/vuex/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/19/vuex/","excerpt":"","text":"Vuex的使用安装Vuex1npm install vuex --save 淘宝镜像1cnpm install vuex --save 新建js文件可以放在store文件夹中命名为index.js 12345678910111213141516171819import Vue from &#x27;vue&#x27;import vuex from &#x27;vuex&#x27;Vue.use(vuex);export default new vuex.Store(&#123; state: &#123; api:&#x27;http://wjdh03.sjgogo.cn/api/&#x27;, token:&quot;57373A7E05CB44079B2F12C14A5E83A9&quot;, domain: &quot;http://www.baidu.com&quot;, notice: true, &#125;, mutations: &#123; domainURI(url) &#123; var durl = /http:\\/\\/([^\\/]+)\\//i; var domain = url.match(durl); return domain[1]; &#125; &#125;&#125;) 调用Vuexmain.js中引入Vuex并使用 1import store from &#x27;./store&#x27; //引入Vuex 载入Vuex12345const vue = new Vue(&#123; router, store, //载入Vuex render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 使用全局状态（变量）在需要使用的组件中 使用调用","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"VUE","slug":"JS/VUE","permalink":"https://hakunamatata052.github.io/categories/JS/VUE/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://hakunamatata052.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://hakunamatata052.github.io/tags/vuex/"}]},{"title":"统计数组中相同值的个数","slug":"Array-of-the-same-kind","date":"2018-12-19T08:24:18.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/19/Array-of-the-same-kind/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/19/Array-of-the-same-kind/","excerpt":"","text":"统计数组中相同值的个数1234567891011121314151617181920212223function arrCheck(arr)&#123; var newArr = []; for(var i=0;i&lt;arr.length;i++)&#123; var newJson = &#123;&#125;; var temp=arr[i]; var count=0; for(var j=0;j&lt;arr.length;j++)&#123; if(arr[j]==temp)&#123; count++; arr[j]=-1; &#125; &#125; if(temp != -1)&#123; newJson.name = temp; newJson.num = count; newArr.push(temp+&quot;:&quot;+count) &#125; &#125; return newArr;&#125;arrCheck([&#123;&quot;name&quot;:&quot;&quot;&#125;,2,3,3,4]);document.write(arrCheck([1,2,3,3,4])); 将数字改为JSON可统计相同JSON值出现的次数","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"}],"tags":[{"name":"js","slug":"js","permalink":"https://hakunamatata052.github.io/tags/js/"},{"name":"数组","slug":"数组","permalink":"https://hakunamatata052.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"Array","slug":"Array","permalink":"https://hakunamatata052.github.io/tags/Array/"}]},{"title":"js求日期差","slug":"timeX","date":"2018-12-19T08:21:00.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/19/timeX/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/19/timeX/","excerpt":"","text":"求时间差函数1234567891011121314var s1 = &#x27;2017-02-26&#x27;; //起始日期var s2 = &#x27;2017-03-02&#x27;; //结束日期var str = DateDiff(s1,s2); function DateDiff(sDate1, sDate2)&#123; //sDate1和sDate2是2002-12-18格式 var aDate, oDate1, oDate2, iDays aDate = sDate1.split(&quot;-&quot;) oDate1 = new Date(aDate[1] + aDate[2] + &#x27;-&#x27; + aDate[0]) //转换为12-18-2002格式 aDate = sDate2.split(&quot;-&quot;) oDate2 = new Date(aDate[1] + &#x27;-&#x27; + aDate[2] + &#x27;-&#x27; + aDate[0]) iDays = parseInt(Math.abs(oDate1 - oDate2) / 1000 / 60 / 60 /24) //把相差的毫秒数转换为天数 return iDays &#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"}],"tags":[{"name":"js","slug":"js","permalink":"https://hakunamatata052.github.io/tags/js/"}]},{"title":"无js实现选项卡效果","slug":"nojs-tabs","date":"2018-12-19T06:52:35.000Z","updated":"2020-08-21T02:57:02.000Z","comments":true,"path":"2018/12/19/nojs-tabs/","link":"","permalink":"https://hakunamatata052.github.io/2018/12/19/nojs-tabs/","excerpt":"无js实现选项卡效果方法一效果展示 实现原理利用锚链接和滚动条实现 缺点基本功能可以满足，但有两个问题，一是由于改变location的hash实现的定位，会触发浏览器原生滚动行为，体验不好；二是选项卡内容的切换“邦邦邦”过于生硬","text":"无js实现选项卡效果方法一效果展示 实现原理利用锚链接和滚动条实现 缺点基本功能可以满足，但有两个问题，一是由于改变location的hash实现的定位，会触发浏览器原生滚动行为，体验不好；二是选项卡内容的切换“邦邦邦”过于生硬 具体代码HTML12345678910111213&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;list&quot; id=&quot;one&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;list&quot; id=&quot;two&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;list&quot; id=&quot;three&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;list&quot; id=&quot;four&quot;&gt;4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;link&quot;&gt; &lt;a class=&quot;click&quot; href=&quot;#one&quot;&gt;1&lt;/a&gt; &lt;a class=&quot;click&quot; href=&quot;#two&quot;&gt;2&lt;/a&gt; &lt;a class=&quot;click&quot; href=&quot;#three&quot;&gt;3&lt;/a&gt; &lt;a class=&quot;click&quot; href=&quot;#four&quot;&gt;4&lt;/a&gt;&lt;/div&gt; CSS1234567891011121314151617181920212223242526272829303132333435363738394041.box &#123; width: 200px; height: 100px; border: 1px solid #ddd; overflow: hidden;&#125;.list &#123; width: 200px; height: 100px; line-height: 100px; background: #ddd; font-size: 80px; text-align: center;&#125;.link &#123; width: 200px; padding-top: 10px; text-align: right;&#125;.click &#123; display: inline-block; width: 20px; height: 20px; line-height: 20px; border: 1px solid #ccc; background: #f7f7f7; color: #333; font-size: 12px; font-weight: bold; text-align: center; text-decoration: none;&#125;.click:hover &#123; background: #eee; color: #345;&#125; 方法二效果展示点击查看效果 实现原理基于控件元素focus触发滚动重定位 缺点选项卡内容切换的时候，还是“邦邦邦”这种干巴巴的效果，并没有滑来滑去那种湿湿的效果 具体代码HTML12345678910111213&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;list&quot;&gt;&lt;input id=&quot;one&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;input id=&quot;two&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;input id=&quot;three&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;input id=&quot;four&quot;&gt;4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;link&quot;&gt; &lt;label class=&quot;click&quot; for=&quot;one&quot;&gt;1&lt;/label&gt; &lt;label class=&quot;click&quot; for=&quot;two&quot;&gt;2&lt;/label&gt; &lt;label class=&quot;click&quot; for=&quot;three&quot;&gt;3&lt;/label&gt; &lt;label class=&quot;click&quot; for=&quot;four&quot;&gt;4&lt;/label&gt;&lt;/div&gt; CSS12345678910111213141516171819.box &#123; width: 20em; height: 10em; border: 1px solid #ddd; overflow: hidden;&#125;.list &#123; height: 100%; background: #ddd; text-align: center; position: relative;&#125;.list &gt; input &#123; position: absolute; top:0; height: 100%; width: 1px; border:0; padding: 0; margin: 0; clip: rect(0 0 0 0);&#125;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://hakunamatata052.github.io/categories/HTML/"}],"tags":[{"name":"tab","slug":"tab","permalink":"https://hakunamatata052.github.io/tags/tab/"},{"name":"选项卡","slug":"选项卡","permalink":"https://hakunamatata052.github.io/tags/%E9%80%89%E9%A1%B9%E5%8D%A1/"},{"name":"无js","slug":"无js","permalink":"https://hakunamatata052.github.io/tags/%E6%97%A0js/"}]}],"categories":[{"name":"JS","slug":"JS","permalink":"https://hakunamatata052.github.io/categories/JS/"},{"name":"three.js","slug":"JS/three-js","permalink":"https://hakunamatata052.github.io/categories/JS/three-js/"},{"name":"miniapp","slug":"JS/miniapp","permalink":"https://hakunamatata052.github.io/categories/JS/miniapp/"},{"name":"nimiapp","slug":"JS/nimiapp","permalink":"https://hakunamatata052.github.io/categories/JS/nimiapp/"},{"name":"uniapp","slug":"JS/uniapp","permalink":"https://hakunamatata052.github.io/categories/JS/uniapp/"},{"name":"react","slug":"JS/react","permalink":"https://hakunamatata052.github.io/categories/JS/react/"},{"name":"日常","slug":"日常","permalink":"https://hakunamatata052.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"webpack","slug":"JS/webpack","permalink":"https://hakunamatata052.github.io/categories/JS/webpack/"},{"name":"CSS","slug":"CSS","permalink":"https://hakunamatata052.github.io/categories/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://hakunamatata052.github.io/categories/HTML/"},{"name":"BOOTSTRAP","slug":"HTML/BOOTSTRAP","permalink":"https://hakunamatata052.github.io/categories/HTML/BOOTSTRAP/"},{"name":"hexo","slug":"hexo","permalink":"https://hakunamatata052.github.io/categories/hexo/"},{"name":"VUE","slug":"JS/VUE","permalink":"https://hakunamatata052.github.io/categories/JS/VUE/"},{"name":"jQuery","slug":"JS/jQuery","permalink":"https://hakunamatata052.github.io/categories/JS/jQuery/"}],"tags":[{"name":"three.js","slug":"three-js","permalink":"https://hakunamatata052.github.io/tags/three-js/"},{"name":"threejs","slug":"threejs","permalink":"https://hakunamatata052.github.io/tags/threejs/"},{"name":"three","slug":"three","permalink":"https://hakunamatata052.github.io/tags/three/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://hakunamatata052.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"请求封装","slug":"请求封装","permalink":"https://hakunamatata052.github.io/tags/%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/"},{"name":"setSelectionRange","slug":"setSelectionRange","permalink":"https://hakunamatata052.github.io/tags/setSelectionRange/"},{"name":"光标位置插入","slug":"光标位置插入","permalink":"https://hakunamatata052.github.io/tags/%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5/"},{"name":"uniapp","slug":"uniapp","permalink":"https://hakunamatata052.github.io/tags/uniapp/"},{"name":"微信SDK","slug":"微信SDK","permalink":"https://hakunamatata052.github.io/tags/%E5%BE%AE%E4%BF%A1SDK/"},{"name":"react jsx","slug":"react-jsx","permalink":"https://hakunamatata052.github.io/tags/react-jsx/"},{"name":"元歌 王者荣耀","slug":"元歌-王者荣耀","permalink":"https://hakunamatata052.github.io/tags/%E5%85%83%E6%AD%8C-%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/"},{"name":"webpack","slug":"webpack","permalink":"https://hakunamatata052.github.io/tags/webpack/"},{"name":"Promise async/await async await 同步异步 异步","slug":"Promise-async-await-async-await-同步异步-异步","permalink":"https://hakunamatata052.github.io/tags/Promise-async-await-async-await-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5-%E5%BC%82%E6%AD%A5/"},{"name":"CSS CSS3","slug":"CSS-CSS3","permalink":"https://hakunamatata052.github.io/tags/CSS-CSS3/"},{"name":"科学上网","slug":"科学上网","permalink":"https://hakunamatata052.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"翻墙","slug":"翻墙","permalink":"https://hakunamatata052.github.io/tags/%E7%BF%BB%E5%A2%99/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://hakunamatata052.github.io/tags/bootstrap/"},{"name":"offset","slug":"offset","permalink":"https://hakunamatata052.github.io/tags/offset/"},{"name":"googleapis","slug":"googleapis","permalink":"https://hakunamatata052.github.io/tags/googleapis/"},{"name":"字体","slug":"字体","permalink":"https://hakunamatata052.github.io/tags/%E5%AD%97%E4%BD%93/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hakunamatata052.github.io/tags/Hexo/"},{"name":"next","slug":"next","permalink":"https://hakunamatata052.github.io/tags/next/"},{"name":"inconfont","slug":"inconfont","permalink":"https://hakunamatata052.github.io/tags/inconfont/"},{"name":"图标","slug":"图标","permalink":"https://hakunamatata052.github.io/tags/%E5%9B%BE%E6%A0%87/"},{"name":"github","slug":"github","permalink":"https://hakunamatata052.github.io/tags/github/"},{"name":"vue","slug":"vue","permalink":"https://hakunamatata052.github.io/tags/vue/"},{"name":"css","slug":"css","permalink":"https://hakunamatata052.github.io/tags/css/"},{"name":"css3","slug":"css3","permalink":"https://hakunamatata052.github.io/tags/css3/"},{"name":"js","slug":"js","permalink":"https://hakunamatata052.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"https://hakunamatata052.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://hakunamatata052.github.io/tags/jquery/"},{"name":"vuex","slug":"vuex","permalink":"https://hakunamatata052.github.io/tags/vuex/"},{"name":"数组","slug":"数组","permalink":"https://hakunamatata052.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"Array","slug":"Array","permalink":"https://hakunamatata052.github.io/tags/Array/"},{"name":"tab","slug":"tab","permalink":"https://hakunamatata052.github.io/tags/tab/"},{"name":"选项卡","slug":"选项卡","permalink":"https://hakunamatata052.github.io/tags/%E9%80%89%E9%A1%B9%E5%8D%A1/"},{"name":"无js","slug":"无js","permalink":"https://hakunamatata052.github.io/tags/%E6%97%A0js/"}]}